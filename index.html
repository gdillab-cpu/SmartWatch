<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Clock-Dilla v25.21</title>
    <style>
        :root {
            /* --- THEME & COLORS --- */
            --c-blue: #0A84FF;
            --c-green: #30D158; 
            --c-red: #FF453A;
            --c-orange: #FF9F0A;
            --c-purple: #BF5AF2;
            --c-grey: #98989D;
            --c-dark: #1C1C1E;
            --c-bg: #000000;
            --c-text: #FFFFFF;
            --c-border: #333333;
            
            /* --- DIMENSIONS --- */
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
            --header-h: 220px; 
            --control-h: 115px;
        }

        /* --- BASE RESET --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Roboto", sans-serif; }
        
        /* PREVENT TEXT SELECTION ON LONG PRESS */
        body { 
            margin: 0; padding: 0; background-color: var(--c-bg); color: var(--c-text); 
            height: 100vh; display: flex; flex-direction: column; overflow: hidden; 
            user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
        }
        
        button { border: none; outline: none; background: none; font-family: inherit; touch-action: manipulation; cursor: pointer; user-select: none; -webkit-user-select: none; }

        /* --- LAYOUT UTILS --- */
        .flex-center { display: flex; align-items: center; justify-content: center; }
        .flex-col { display: flex; flex-direction: column; }
        .hidden { display: none !important; }
        .dimmed { opacity: 0.3; pointer-events: none; }

        /* --- 1. TOP BAR (TIMER) --- */
        .top-bar {
            height: var(--header-h); flex-shrink: 0;
            padding: calc(var(--safe-top) + 10px) 10px 10px;
            background: #121212; border-bottom: 1px solid var(--c-border);
            display: flex; gap: 8px; z-index: 50;
        }
        .timer-display {
            flex: 1; background: #222; border-radius: 16px; position: relative;
            display: grid; grid-template-columns: 1fr 1fr;
            border: 1px solid rgba(10, 132, 255, 0.3); /* LIGHT BLUE OUTLINE */
        }
        /* Vertical Divider */
        .timer-display::after {
            content: ''; position: absolute; left: 50%; top: 15%; bottom: 15%;
            width: 1px; background: #333; transform: translateX(-50%);
        }
        .td-col {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.2s; cursor: pointer;
        }
        
        /* State: Disabled (Faint Grey) */
        .td-col.disabled { opacity: 0.3; }
        .td-col.disabled .td-val { color: #555; } 

        .td-lbl { font-size: 11px; color: #666; font-weight: 700; text-transform: uppercase; margin-bottom: 4px; }
        
        /* Value Colors - Reverted to 48px */
        .td-val { 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; 
            font-size: 48px; 
            font-weight: 300; 
            line-height: 1; 
            font-variant-numeric: tabular-nums; 
            color: #fff; 
        }
        
        .td-pred { font-size: 18px; font-weight: 800; text-transform: uppercase; margin-top: 10px; min-height: 24px; color: #fff; }
        
        /* --- 2. CONTROL PANEL --- */
        .control-panel {
            min-height: var(--control-h); flex-shrink: 0; background: var(--c-dark);
            border-bottom: 1px solid var(--c-border); display: flex;
        }
        
        /* Reference Table Section */
        .cp-left { flex: 1; display: flex; padding: 6px 0; }
        .ref-section { width: 60%; padding-left: 8px; border-right: 1px solid var(--c-border); display: flex; flex-direction: column; justify-content: center; }
        .ref-header { text-align: center; font-size: 11px; color: var(--c-grey); font-weight: 700; margin-bottom: 4px; text-transform: uppercase; }
        .ref-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .ref-table td { padding: 2px 0; border: none; text-align: center; } 
        .ref-table td:first-child { text-align: left; font-weight: 700; color: #ccc; }

        /* Profile Selection Section */
        .profile-section { width: 40%; padding: 4px 8px; display: flex; flex-direction: column; gap: 4px; justify-content: center; }
        .p-row { display: flex; gap: 4px; flex: 1; }
        .p-btn {
            flex: 1; background: #252525; border: 1px solid #333; border-radius: 6px;
            color: #666; font-size: 11px; font-weight: 700; text-transform: uppercase;
            display: flex; align-items: center; justify-content: center; transition: 0.1s;
        }
        .p-btn.active { background: #444; color: #fff; border-color: #999; }
        
        /* Menu Button */
        .menu-strip {
            width: 50px; background: #252525; border-left: 1px solid var(--c-border);
            display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .menu-text { writing-mode: vertical-rl; transform: rotate(180deg); color: var(--c-grey); font-weight: 800; font-size: 14px; letter-spacing: 2px; }

        /* --- 3. INPUT TRAY (The Grid) --- */
        .flash-tray {
            flex: 1; background: #000; padding: 10px; 
            padding-bottom: calc(var(--safe-bottom) + 190px); 
            display: flex; flex-direction: column; 
            justify-content: flex-start; 
            padding-top: 6px;
            opacity: 0.3; pointer-events: none; transition: opacity 0.2s;
            overflow-y: auto; 
        }
        .flash-tray.active { opacity: 1; pointer-events: auto; }
        
        .flash-grid {
            display: grid; grid-template-columns: 20% 1fr 1fr 1fr 15%; grid-template-rows: repeat(4, 55px);
            gap: 6px; width: 100%;
        }
        .fg-btn {
            border: 1px solid #333; border-radius: 8px;
            font-weight: 700; font-size: 12px; display: flex; align-items: center; justify-content: center;
        }
        .fg-btn:active { transform: scale(0.96); filter: brightness(1.2); }
        .fg-btn.selected { color: #fff; border-color: currentColor; border-width: 2px; }
        
        /* Specific Grid Shading */
        .fg-player { background: #333; color: #ccc; } 
        .fg-player.selected { background: var(--c-blue); border-color: var(--c-blue); color:#fff; }
        
        .fg-zone { background: #1a1a1a; color: #fff; } 
        .fg-zone.selected { background: var(--c-green); border-color: var(--c-green); color: #000; }
        
        .fg-sweep { background: #333; color: #ccc; } 
        .fg-sweep.selected { background: var(--c-purple); border-color: var(--c-purple); color:#fff; }
        .fg-sweep.disabled { opacity: 0.1; pointer-events: none; }

        .fg-discard { background: #111; color: #555; border: 1px dashed #333; font-style: italic; font-size: 10px; }
        .fg-discard:active { background: #222; color: #888; }

        /* --- 4. MAIN ACTION BUTTON --- */
        .controls-area {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(28,28,30,0.95); backdrop-filter: blur(10px);
            padding: 12px; padding-bottom: max(60px, var(--safe-bottom));
            border-top: 1px solid var(--c-border); z-index: 100;
        }
        #btn-main {
            width: 100%; height: 150px; border-radius: 22px;
            font-size: 40px; font-weight: 800; color: white; text-transform: uppercase; letter-spacing: 2px;
            transition: transform 0.1s, background-color 0.2s;
        }
        #btn-main:active { transform: scale(0.98); }
        
        /* Dynamic Button States */
        .btn-state-start { background: var(--c-green); box-shadow: 0 4px 30px rgba(48, 209, 88, 0.3); }
        .btn-state-split { background: var(--c-blue); box-shadow: 0 4px 30px rgba(10, 132, 255, 0.3); }
        .btn-state-int { background: var(--c-red); box-shadow: 0 4px 30px rgba(255, 69, 58, 0.3); }

        /* --- 5. MODALS --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 200;
            display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.open { display: flex; }
        
        .modal-card {
            background: #222; width: 95%; max-width: 400px; max-height: 80vh;
            border-radius: 16px; border: 1px solid #444; padding: 20px;
            display: flex; flex-direction: column;
        }
        .modal-header { font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px; text-align: center; margin-bottom: 15px; }
        
        .modal-content-scroll { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }

        /* Generic Modal List */
        .modal-list { list-style: none; padding: 0; margin: 0; width: 100%; }
        .modal-list li button {
            width: 100%; padding: 14px; margin-bottom: 8px; background: #2A2A2A;
            color: #fff; border: 1px solid #333; border-radius: 8px; font-weight: 700;
        }
        
        /* History Table */
        .hist-table { width: 100%; font-size: 12px; color: #fff; border-collapse: collapse; }
        .hist-table th { text-align: center; border-bottom: 1px solid #444; padding: 8px 4px; color: #888; position: sticky; top: 0; background: #222; }
        .hist-table td { border-bottom: 1px solid #333; padding: 10px 4px; text-align: center; }
        .h-dim { color: #555; }
        .h-outlier { color: var(--c-orange); }

        /* Graph Canvas */
        #graph-canvas { background: #111; width: 100%; height: 250px; border: 1px solid #333; border-radius: 8px; }
        .graph-legend { display: flex; justify-content: center; gap: 12px; margin-top: 10px; flex-wrap: wrap; }
        .legend-item { font-size: 10px; font-weight: 700; display: flex; align-items: center; gap: 4px; color: #ccc; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

        /* Rename/Profile Input */
        .input-rename {
            width: 100%; background: #333; border: 1px solid #555; color: white; padding: 12px;
            border-radius: 8px; font-size: 18px; text-transform: uppercase; text-align: center; margin-bottom: 15px; outline: none;
        }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; padding: 4px 0; border-bottom: 1px solid #333; }
        .stat-row span:last-child { font-family: monospace; font-weight: 700; color: #fff; }
        
        .stepper-row { display: flex; gap: 10px; margin-top: 15px; margin-bottom: 15px; align-items: center; justify-content: center;}
        .step-btn { flex: 1; height: 40px; background: #333; border-radius: 8px; font-size: 16px; font-weight: 700; color: #ccc; }
        .step-btn:active { background: #555; color: #fff; }
        .offset-val { font-family: monospace; font-size: 24px; color: var(--c-green); width: 80px; text-align: center; }
    </style>
</head>
<body>

    <!-- UI: TOP BAR -->
    <div class="top-bar">
        <div class="timer-display">
            <!-- Left: Back-Hog (Toggleable) -->
            <div class="td-col" id="disp-bh" data-action="toggle-bh">
                <div class="td-lbl">Back-Hog</div>
                <div class="td-val val-bh">--</div>
                <div class="td-pred" id="pred-bh"></div>
            </div>
            <!-- Right: Hog-Hog (Toggleable) -->
            <div class="td-col" id="disp-hh" data-action="toggle-hh">
                <div class="td-lbl">Hog-Hog</div>
                <div class="td-val val-hh">--</div>
                <div class="td-pred" id="pred-hh"></div>
            </div>
        </div>
    </div>

    <!-- UI: CONTROL PANEL -->
    <div class="control-panel">
        <div class="cp-left">
            <div class="ref-section">
                <div class="ref-header" id="ref-header">Live Ice Speeds</div>
                <table class="ref-table" id="ref-table">
                    <!-- Populated by JS -->
                </table>
            </div>
            <div class="profile-section" id="profile-container">
                <div class="p-row">
                    <button class="p-btn" id="btn-Skip" data-id="Skip">SKIP</button>
                    <button class="p-btn" id="btn-3rd" data-id="3rd">3RD</button>
                </div>
                <div class="p-row">
                    <button class="p-btn" id="btn-2nd" data-id="2nd">2ND</button>
                    <button class="p-btn" id="btn-Lead" data-id="Lead">LEAD</button>
                </div>
            </div>
        </div>
        <div class="menu-strip" data-action="open-menu">
            <div class="menu-text">MENU</div>
        </div>
    </div>

    <!-- UI: FLASH INPUT TRAY -->
    <div class="flash-tray" id="flash-tray">
        <div class="flash-grid" id="flash-grid">
            <!-- Populated by JS -->
        </div>
    </div>

    <!-- UI: FOOTER ACTION -->
    <div class="controls-area">
        <button id="btn-main" class="btn-state-start">START</button>
    </div>

    <!-- MODALS (Generic Container) -->
    <div class="modal-overlay" id="modal-overlay">
        <!-- Content injected dynamically -->
        <div class="modal-card" id="modal-content"></div>
    </div>

    <script>
        /** * =========================================
         * 1. CONFIGURATION
         * =========================================
         */
        const CONFIG = {
            physics: {
                bhSlope: -30.0, bhIntercept: 139.5,
                hhSlope: -5.4, hhIntercept: 98.0,
            },
            limits: {
                minBH: 2.0, maxBH: 6.0, autoHog: 5.5,
                minHH: 7.0, maxHH: 22.0, timeout: 19.0
            },
            zones: [
                {v: 1.0, n: "High", d: 2.5}, {v: 2.0, n: "Mid", d: 7.5}, {v: 3.0, n: "Tight", d: 12.5},
                {v: 4.0, n: "T 12", d: 15.5}, {v: 5.0, n: "T 8", d: 17.5}, {v: 6.0, n: "T 4", d: 19.5},
                {v: 7.0, n: "TEE", d: 21.0},
                {v: 8.0, n: "B 4", d: 22.5}, {v: 9.0, n: "B 8", d: 24.5}, {v: 10.0, n: "B 12", d: 26.5},
                {v: 10.5, n: "THRU", d: 29.75}, {v: 11.0, n: "Hack", d: 33.0}, {v: 11.5, n: "Board", d: 39.0}
            ],
            sweeps: [ {n:'N/A', v:0}, {n:'L', v:3}, {n:'M', v:6}, {n:'H', v:9} ],
            // 5-Column Grid Layout Map (SWAPPED B4/B8 - Corrected)
            gridMap: [
                {t:'p', id:'Skip'}, {t:'z', n:'High'}, {t:'z', n:'Mid'}, {t:'z', n:'Tight'}, {t:'s', n:'N/A'},
                {t:'p', id:'3rd'},  {t:'z', n:'T 12'}, {t:'z', n:'T 8'}, {t:'d', n:'DISCARD'}, {t:'s', n:'L'},
                {t:'p', id:'2nd'},  {t:'z', n:'T 4'},  {t:'z', n:'TEE'}, {t:'z', n:'B 8'},  {t:'s', n:'M'},
                {t:'p', id:'Lead'}, {t:'z', n:'THRU'},{t:'z', n:'B 4'}, {t:'z', n:'B 12'}, {t:'s', n:'H'}
            ],
            colors: { 'Skip': '#FF453A', '3rd': '#FF9F0A', '2nd': '#0A84FF', 'Lead': '#30D158', '-': '#98989D' }
        };

        /**
         * =========================================
         * 2. STOPWATCH CLASS (Logic Only)
         * =========================================
         */
        class Stopwatch {
            constructor() {
                this.state = 'IDLE'; // IDLE, RUNNING, INTERVAL, FINISHED
                this.t0 = 0; // Start Time
                this.t1 = 0; // Hog Time
                this.splitBH = 0;
                this.splitHH = 0;
                this.enabledBH = true; 
                this.enabledHH = true;
                this.rafId = null;
                this.onTick = null; // Callback for UI updates
                this.onFinish = null; // Callback when timer stops
            }

            reset() {
                this.stop();
                this.state = 'IDLE';
                this.splitBH = 0;
                this.splitHH = 0;
                if(this.onTick) this.onTick(this);
            }

            mainAction() {
                const now = Date.now();
                
                if (this.state === 'IDLE' || this.state === 'FINISHED') {
                    // Start
                    if(!this.enabledBH) {
                         // Direct to HH interval
                         this.state = 'INTERVAL';
                         this.t1 = now;
                         this.startLoop();
                    } else {
                         this.state = 'RUNNING';
                         this.t0 = now;
                         this.startLoop();
                    }
                } 
                else if (this.state === 'RUNNING') {
                    // Split at Hog 1
                    this.t1 = now;
                    this.splitBH = (this.t1 - this.t0) / 1000;
                    
                    if (this.splitBH > CONFIG.limits.autoHog) {
                        // Auto-Hog logic: The click was actually the FIRST hog line
                        this.splitBH = 0; // Invalidate BH
                        this.t0 = 0;
                        if(this.enabledHH) {
                            this.state = 'INTERVAL';
                        } else {
                            // If HH is disabled and we Auto-Hogged, we just finish (nothing to time)
                            this.finish();
                        }
                    } else {
                        // Normal Split
                        if(this.enabledHH) {
                            this.state = 'INTERVAL';
                        } else {
                            this.finish();
                        }
                    }
                } 
                else if (this.state === 'INTERVAL') {
                    // Split at Hog 2
                    this.splitHH = (now - this.t1) / 1000;
                    this.finish();
                }
            }

            startLoop() {
                if(this.rafId) cancelAnimationFrame(this.rafId);
                const loop = () => {
                    const now = Date.now();
                    
                    if (this.state === 'RUNNING') {
                        const cur = (now - this.t0) / 1000;
                        if(this.onTick) this.onTick({ ...this, liveBH: cur });
                        
                        // Auto-Hog Transition (Visual only, logic handled in click)
                        if (cur > CONFIG.limits.autoHog) {
                            this.state = 'INTERVAL';
                            this.t1 = this.t0; // Treat start as T1
                            this.t0 = 0;
                            this.splitBH = 0;
                        }
                    } 
                    else if (this.state === 'INTERVAL') {
                        const cur = (now - this.t1) / 1000;
                        if(this.onTick) this.onTick({ ...this, liveHH: cur });
                        
                        // Timeout Logic (19s)
                        if (cur > CONFIG.limits.timeout) {
                            this.splitHH = 0; // Mark as invalid/timeout
                            this.finish();
                        }
                    }
                    
                    if(this.state !== 'IDLE' && this.state !== 'FINISHED') {
                        this.rafId = requestAnimationFrame(loop);
                    }
                };
                this.rafId = requestAnimationFrame(loop);
            }

            stop() {
                if(this.rafId) cancelAnimationFrame(this.rafId);
            }

            finish() {
                this.state = 'FINISHED';
                this.stop();
                if (this.onFinish) this.onFinish(this);
            }
        }

        /**
         * =========================================
         * 3. SESSION MANAGER (Data & Stats)
         * =========================================
         */
        class Session {
            constructor() {
                this.history = [];
                this.archives = [];
                this.profiles = { 'Skip':'SKIP', '3rd':'3RD', '2nd':'2ND', 'Lead':'LEAD' };
                this.manualOffsets = { 'Skip':0, '3rd':0, '2nd':0, 'Lead':0 };
                this.activeProfile = 'TEAM';
                this.iceOffsetBH = 0; // TEAM calibration
                this.iceOffsetHH = 0; // TEAM calibration
                this.outliersBH = new Set();
                this.outliersHH = new Set();
                this.load();
            }

            load() {
                const d = localStorage.getItem('cd_v25');
                if(d) {
                    const parsed = JSON.parse(d);
                    this.history = parsed.history || [];
                    this.archives = parsed.archives || [];
                    this.profiles = parsed.profiles || this.profiles;
                    this.manualOffsets = parsed.manualOffsets || this.manualOffsets;
                    
                    // If archives is empty, ensure the sample game exists
                    if (this.archives.length === 0) this.createSampleArchive();
                    
                    this.recalcStats();
                } else {
                    // New Install
                    this.createSampleArchive();
                    this.save();
                }
            }

            save() {
                const d = { 
                    history: this.history, 
                    archives: this.archives,
                    profiles: this.profiles,
                    manualOffsets: this.manualOffsets
                };
                localStorage.setItem('cd_v25', JSON.stringify(d));
                this.recalcStats();
            }

            createSampleArchive() {
                // Hardcoded data from 2025 Brier Semifinal Gushue
                const sampleGame = {
                    id: 1739720000000,
                    name: "Sample: 2025 Brier Semifinal",
                    date: "2025-03-08",
                    profiles: { 'Skip':'SKIP', '3rd':'3RD', '2nd':'2ND', 'Lead':'LEAD' },
                    history: [
                        { id: 1, player: '3rd', bh: 4.31, hh: 14.84, useBH: true, useHH: true, actual: 17.5, sweep: 3, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:00:00Z" },
                        { id: 2, player: 'Skip', bh: 4.04, hh: 14.81, useBH: true, useHH: true, actual: 19.5, sweep: 3, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:05:00Z" },
                        { id: 3, player: '-', bh: 4.04, hh: 14.27, useBH: true, useHH: true, actual: 21.0, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:10:00Z" },
                        { id: 4, player: '-', bh: 4.04, hh: 14.47, useBH: true, useHH: true, actual: 17.5, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:15:00Z" },
                        { id: 5, player: '-', bh: 4.29, hh: 14.20, useBH: true, useHH: true, actual: 19.5, sweep: 6, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:20:00Z" },
                        { id: 6, player: '2nd', bh: 4.34, hh: 14.94, useBH: true, useHH: true, actual: 17.5, sweep: 3, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:25:00Z" },
                        { id: 7, player: '-', bh: 4.39, hh: 15.18, useBH: true, useHH: true, actual: 15.5, sweep: 6, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:30:00Z" },
                        { id: 8, player: '3rd', bh: 4.11, hh: 13.87, useBH: true, useHH: true, actual: 21.0, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:35:00Z" },
                        { id: 9, player: 'Skip', bh: 4.16, hh: 14.80, useBH: true, useHH: true, actual: 17.5, sweep: 6, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:40:00Z" },
                        { id: 10, player: '-', bh: 4.29, hh: 14.48, useBH: true, useHH: true, actual: 19.5, sweep: 3, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:45:00Z" },
                        { id: 11, player: '2nd', bh: 4.29, hh: 15.41, useBH: true, useHH: true, actual: 15.5, sweep: 6, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:50:00Z" },
                        { id: 12, player: '-', bh: 4.27, hh: 15.50, useBH: true, useHH: true, actual: 17.5, sweep: 9, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T19:55:00Z" },
                        { id: 13, player: '3rd', bh: 4.37, hh: 14.08, useBH: true, useHH: true, actual: 22.5, sweep: 9, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:00:00Z" },
                        { id: 14, player: '-', bh: 4.08, hh: 13.97, useBH: true, useHH: true, actual: 26.5, sweep: 6, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:05:00Z" },
                        { id: 15, player: 'Skip', bh: 3.99, hh: 13.94, useBH: true, useHH: true, actual: 24.5, sweep: 3, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:10:00Z" },
                        { id: 16, player: '-', bh: 3.99, hh: 14.43, useBH: true, useHH: true, actual: 19.5, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:15:00Z" },
                        { id: 17, player: '-', bh: 4.25, hh: 14.17, useBH: true, useHH: true, actual: 22.5, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:20:00Z" },
                        { id: 18, player: '-', bh: 4.36, hh: 14.34, useBH: true, useHH: true, actual: 19.5, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:25:00Z" },
                        { id: 19, player: '-', bh: 4.36, hh: 13.94, useBH: true, useHH: true, actual: 22.5, sweep: 0, offsetBH:0, offsetHH:0, timestamp: "2025-03-08T20:30:00Z" }
                    ]
                };
                // Check if already exists to avoid dupes on refresh/update
                if (!this.archives.find(a => a.id === sampleGame.id)) {
                    this.archives.push(sampleGame);
                }
            }

            addShot(shotData) {
                // CAPTURE CALIBRATION STATE AT TIME OF SHOT FOR STATIC ERROR PLOTS
                this.history.unshift({
                    id: Date.now(),
                    ...shotData,
                    offsetBH: this.iceOffsetBH, 
                    offsetHH: this.iceOffsetHH,
                    timestamp: new Date().toISOString()
                });
                if(this.history.length > 150) this.history.pop();
                this.save(); // Triggers recalcStats
            }

            // --- ARCHIVING ---
            archiveCurrentGame(name) {
                this.archives.unshift({
                    id: Date.now(),
                    name: name || `Game ${this.archives.length + 1}`,
                    date: new Date().toLocaleDateString(),
                    history: [...this.history], // Deep copy history
                    profiles: {...this.profiles}
                });
                this.save();
            }

            loadArchive(id) {
                const game = this.archives.find(a => a.id === id);
                if(game) {
                    this.history = [...game.history];
                    this.profiles = {...game.profiles};
                    this.save(); // Triggers recalc/update
                }
            }

            deleteArchive(id) {
                this.archives = this.archives.filter(a => a.id !== id);
                this.save();
            }

            // --- CALIBRATION ---
            recalcStats() {
                this.outliersBH.clear();
                this.outliersHH.clear();
                this.iceOffsetBH = this.calculateSmartOffset('BH');
                this.iceOffsetHH = this.calculateSmartOffset('HH');
            }

            calculateSmartOffset(type) {
                const validShots = this.history.filter(s => {
                    if (type === 'BH') return s.useBH && s.actual !== null;
                    if (type === 'HH') return s.useHH && s.actual !== null;
                    return false;
                });

                if (validShots.length === 0) return 0;

                const dataPoints = validShots.map((s, index) => {
                    const slope = type === 'BH' ? CONFIG.physics.bhSlope : CONFIG.physics.hhSlope;
                    const intercept = type === 'BH' ? CONFIG.physics.bhIntercept : CONFIG.physics.hhIntercept;
                    const time = type === 'BH' ? s.bh : s.hh;
                    const rawPred = (slope * time) + intercept;
                    
                    let adjustedActual = s.actual;
                    if (type === 'BH' && s.sweep) adjustedActual -= s.sweep; 

                    const error = adjustedActual - rawPred;

                    // Weighting Logic
                    let weight = 1.0;
                    if (type === 'HH') {
                        // Recency Only for HH
                        if (index < 4) weight = 1.0;
                        else if (index < 12) weight = 0.6;
                        else weight = 0.2;
                    } 
                    // BH is Flat (1.0)

                    if (s.actual < 14.0) weight *= 0.5; // Guards precision penalty

                    return { id: s.id, error, weight };
                });

                const stats1 = this.getWeightedStats(dataPoints);
                
                const cleanData = dataPoints.filter(d => {
                    if (stats1.sd === 0) return true;
                    const isOutlier = Math.abs(d.error - stats1.mean) > (2 * stats1.sd);
                    if(isOutlier) {
                        if(type === 'BH') this.outliersBH.add(d.id);
                        else this.outliersHH.add(d.id);
                    }
                    return !isOutlier;
                });

                if (cleanData.length === 0) return stats1.mean;
                const stats2 = this.getWeightedStats(cleanData);
                return stats2.mean;
            }

            getWeightedStats(data) {
                let sumW = 0; let sumValW = 0;
                data.forEach(d => { sumW += d.weight; sumValW += (d.error * d.weight); });
                if (sumW === 0) return { mean: 0, sd: 0 };
                const mean = sumValW / sumW;

                let sumSqDiffW = 0;
                data.forEach(d => { sumSqDiffW += (Math.pow(d.error - mean, 2) * d.weight); });
                return { mean, sd: Math.sqrt(sumSqDiffW / sumW) };
            }

            getPrediction(type, time) {
                const slope = type === 'BH' ? CONFIG.physics.bhSlope : CONFIG.physics.hhSlope;
                const int = type === 'BH' ? CONFIG.physics.bhIntercept : CONFIG.physics.hhIntercept;
                
                let offset = type === 'BH' ? this.iceOffsetBH : this.iceOffsetHH;
                
                if(this.activeProfile !== 'TEAM' && this.manualOffsets[this.activeProfile]) {
                    if(type === 'BH') offset += (this.manualOffsets[this.activeProfile] * slope); 
                }
                
                const dist = (slope * time) + int + offset;
                if (dist > 42.0) return null;

                if(type === 'BH') {
                    if(time < CONFIG.limits.minBH) return null;
                    return dist;
                }
                if(type === 'HH') {
                    if(time < CONFIG.limits.minHH) return null;
                    return dist;
                }
                return null;
            }

            getPlayerMeanError(profileId) {
                const shots = this.history.filter(s => s.player === profileId && s.useBH && s.actual !== null);
                if (shots.length === 0) return 0;
                let sumErr = 0;
                shots.forEach(s => {
                    const pred = (CONFIG.physics.bhSlope * s.bh) + CONFIG.physics.bhIntercept;
                    const act = s.actual - (s.sweep||0);
                    sumErr += (act - pred);
                });
                return sumErr / shots.length;
            }

            renameProfile(id, newName) {
                if(!newName) return;
                this.profiles[id] = newName.substring(0, 5).toUpperCase();
                this.save();
            }
            
            setManualOffset(id, val) {
                this.manualOffsets[id] = parseFloat(val.toFixed(2));
                this.save();
            }

            exportCSV(saveName) {
                // Auto-archive
                this.archiveCurrentGame(saveName);

                let csv = "Pos,B-H,Used,H-H,Used,Result,Sweep\n";
                this.history.forEach(s => { 
                    const sw = s.sweep ? (s.sweep === 3 ? 'L' : s.sweep === 6 ? 'M' : s.sweep === 9 ? 'H' : 'N/A') : 'N/A';
                    // Export with '-' instead of 'TEAM'
                    const pName = (s.player === 'TEAM' || !s.player) ? '-' : s.player;
                    csv += `${pName},${s.bh.toFixed(2)},${s.useBH},${s.hh.toFixed(2)},${s.useHH},${s.actual},${sw}\n`; 
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `${saveName}.csv`; a.click();
            }
        }

        /**
         * =========================================
         * 4. UI CONTROLLER (View)
         * =========================================
         */
        class UI {
            constructor(app) {
                this.app = app;
                this.els = {
                    btnMain: document.getElementById('btn-main'),
                    valBH: document.querySelector('.val-bh'),
                    valHH: document.querySelector('.val-hh'),
                    predBH: document.getElementById('pred-bh'),
                    predHH: document.getElementById('pred-hh'),
                    flashTray: document.getElementById('flash-tray'),
                    refTable: document.getElementById('ref-table'),
                    modal: document.getElementById('modal-overlay'),
                    modalContent: document.getElementById('modal-content')
                };
                
                this.tempShot = null; 
                this.longPressTimer = null;
                this.tempOffset = 0;
                this.lastActionTime = 0; // Debounce tracking
                
                this.renderGrid();
                this.bindEvents();
            }

            bindEvents() {
                const handleTouch = (e) => {
                    const target = e.target.closest('[data-action]');
                    if(!target) return;
                    e.preventDefault(); 
                    this.handleAction(target.dataset.action, target);
                };

                document.body.addEventListener('touchend', handleTouch, {passive: false});
                document.body.addEventListener('click', (e) => {
                    const target = e.target.closest('[data-action]');
                    if(target) this.handleAction(target.dataset.action, target);
                });

                // MAIN BUTTON: INSTANT TRIGGER
                const btnMain = document.getElementById('btn-main');
                if(btnMain) {
                    // Mobile: Instant start
                    btnMain.addEventListener('touchstart', (e) => {
                        e.preventDefault(); 
                        this.handleAction('main-btn', btnMain);
                    }, {passive: false});
                    
                    // Desktop: Instant start (mousedown)
                    btnMain.addEventListener('mousedown', (e) => {
                        this.handleAction('main-btn', btnMain);
                    });
                }

                // Modal Close on Overlay Click
                this.els.modal.addEventListener('click', (e) => {
                    if(e.target === this.els.modal) {
                        if(this.els.modal.dataset.view === 'sub') this.showMenu();
                        else this.els.modal.classList.remove('open');
                    }
                });

                ['Skip','3rd','2nd','Lead'].forEach(id => {
                    const btn = document.getElementById(`btn-${id}`);
                    if(!btn) return;
                    
                    const start = (e) => {
                        this.longPressTimer = setTimeout(() => {
                            this.longPressTimer = null;
                            this.showProfileModal(id);
                        }, 800);
                    };
                    const end = (e) => {
                        if (e.type === 'touchend') e.preventDefault(); 
                        if (this.longPressTimer) {
                            clearTimeout(this.longPressTimer);
                            this.longPressTimer = null;
                            const isAlreadyActive = this.app.session.activeProfile === id;
                            this.app.session.activeProfile = isAlreadyActive ? 'TEAM' : id;
                            this.updateProfileUI();
                            this.updateRefTable();
                        }
                    };
                    btn.addEventListener('touchstart', start, {passive:true});
                    btn.addEventListener('touchend', end);
                    btn.addEventListener('mousedown', start);
                    btn.addEventListener('mouseup', end);
                });
            }

            handleAction(action, el) {
                const now = Date.now();
                if (now - this.lastActionTime < 200) return; // 200ms global cooldown
                this.lastActionTime = now;

                switch(action) {
                    case 'main-btn': this.app.timer.mainAction(); break;
                    case 'reset': this.app.reset(); break;
                    case 'toggle-bh': 
                        this.app.timer.enabledBH = !this.app.timer.enabledBH;
                        document.getElementById('disp-bh').classList.toggle('disabled', !this.app.timer.enabledBH);
                        this.update(this.app.timer);
                        break;
                    case 'toggle-hh': 
                        this.app.timer.enabledHH = !this.app.timer.enabledHH;
                        document.getElementById('disp-hh').classList.toggle('disabled', !this.app.timer.enabledHH);
                        this.update(this.app.timer);
                        break;
                    case 'grid-player':
                        if(this.tempShot) {
                            this.tempShot.player = (this.tempShot.player === el.dataset.id) ? 'TEAM' : el.dataset.id;
                            this.highlightGrid();
                        }
                        break;
                    case 'grid-zone':
                        if(this.tempShot) {
                            this.tempShot.actual = parseFloat(el.dataset.val);
                            this.checkCommit();
                        }
                        break;
                    case 'grid-sweep':
                        if(this.tempShot) {
                            this.tempShot.sweep = parseInt(el.dataset.val);
                            this.checkCommit();
                        }
                        break;
                    case 'grid-discard':
                        this.tempShot = null;
                        this.els.flashTray.classList.remove('active');
                        this.setBtnState('start', 'START');
                        break;
                    case 'open-menu': this.showMenu(); break;
                    case 'back-menu': this.showMenu(); break;
                    case 'close-modal': this.els.modal.classList.remove('open'); break;
                    case 'save-profile':
                        const val = document.getElementById('rename-input').value;
                        this.app.session.renameProfile(el.dataset.id, val);
                        this.app.session.setManualOffset(el.dataset.id, this.tempOffset);
                        this.updateProfileUI();
                        this.renderGrid(); 
                        this.updateRefTable();
                        this.els.modal.classList.remove('open');
                        break;
                    case 'adj-offset':
                        this.tempOffset += parseFloat(el.dataset.val);
                        document.getElementById('offset-val').innerText = (this.tempOffset > 0 ? "+" : "") + this.tempOffset.toFixed(2);
                        break;
                    case 'open-archives': this.showArchives(); break;
                    case 'load-archive': 
                        if(confirm("Load old game? Unsaved progress will be lost.")) {
                            this.app.session.loadArchive(parseInt(el.dataset.id));
                            this.updateRefTable();
                            this.updateProfileUI();
                            this.els.modal.classList.remove('open');
                        }
                        break;
                    case 'delete-archive':
                        if(confirm("Delete this saved game?")) {
                            this.app.session.deleteArchive(parseInt(el.dataset.id));
                            this.showArchives(); // Refresh list
                        }
                        break;
                    case 'do-export':
                        const name = prompt("Name this game:", "Curling_Game_" + new Date().toLocaleDateString().replace(/\//g,'-'));
                        if(name) {
                            this.app.session.exportCSV(name);
                            this.els.modal.classList.remove('open');
                        }
                        break;
                }
            }

            update(timerState) {
                // Update Numeric Displays
                if (timerState.state === 'RUNNING') {
                    this.els.valBH.innerText = timerState.liveBH.toFixed(2);
                    this.els.valBH.classList.remove('idle'); 
                    // No Live Prediction
                    this.els.predBH.innerText = "";
                    this.els.predHH.innerText = ""; // Clear HH immediately
                    this.setBtnState('split', 'HOG 1');
                    
                    this.els.valHH.innerText = "--";
                    this.els.valHH.classList.add('idle'); // Revert to Idle Grey
                } 
                else if (timerState.state === 'INTERVAL') {
                    this.els.valHH.innerText = timerState.liveHH.toFixed(2);
                    this.els.valHH.classList.remove('idle');
                    // No Live Prediction for HH currently running
                    this.els.predHH.innerText = "";
                    this.setBtnState('int', 'HOG 2');

                    // If BH was skipped or invalid
                    if(timerState.splitBH === 0) {
                        this.els.valBH.innerText = "--";
                        this.els.valBH.classList.add('idle');
                    } else {
                        // IMMEDIATE B-H PREDICTION
                        // Time is stopped, show estimate
                        this.predict('BH', timerState.splitBH);
                    }
                }
                else if (timerState.state === 'IDLE') {
                    this.setBtnState('start', 'START');
                    // Keep existing values if just stopped short, otherwise clear
                    // Logic handled in activateInput/reset
                }
            }

            predict(type, time) {
                const dist = this.app.session.getPrediction(type, time);
                const el = type === 'BH' ? this.els.predBH : this.els.predHH;
                
                if (dist === null) { el.innerText = ""; return; }
                
                let label = "?"; let min = 99;
                CONFIG.zones.forEach(z => {
                    const diff = Math.abs(z.d - dist);
                    if(diff < min) { min = diff; label = z.n; }
                });
                el.innerText = label;
            }

            activateInput(finalState) {
                // Display predictions for the final static times
                if(finalState.enabledBH) this.predict('BH', finalState.splitBH);
                if(finalState.enabledHH && finalState.splitHH > 0) this.predict('HH', finalState.splitHH);

                // INPUT FILTERING: Check if times are realistic
                const bhValid = finalState.enabledBH && finalState.splitBH >= CONFIG.limits.minBH;
                const hhValid = finalState.enabledHH && finalState.splitHH >= CONFIG.limits.minHH;

                // If both enabled but both invalid, or single enabled and invalid -> Reset to "Stop" state visually (button ready to start)
                const bhTooShort = finalState.enabledBH && finalState.splitBH < CONFIG.limits.minBH;
                const hhTooShort = finalState.enabledHH && finalState.splitHH < CONFIG.limits.minHH;
                
                // Logic: If active timers are ALL too short, don't open tray.
                // Leave times visible, reset Main Button to START.
                
                let abort = false;
                // Case 1: Both Enabled, both short
                if (finalState.enabledBH && finalState.enabledHH && bhTooShort && hhTooShort) abort = true;
                // Case 2: BH Only, BH Short
                if (finalState.enabledBH && !finalState.enabledHH && bhTooShort) abort = true;
                // Case 3: HH Only, HH Short
                if (!finalState.enabledBH && finalState.enabledHH && hhTooShort) abort = true;
                
                if (abort) {
                     this.setBtnState('start', 'START');
                     return; 
                }
                
                // If we got here, at least one time is valid enough to record
                this.tempShot = {
                    player: this.app.session.activeProfile,
                    bh: finalState.splitBH,
                    hh: finalState.splitHH,
                    useBH: bhValid && (finalState.splitBH < CONFIG.limits.maxBH),
                    useHH: hhValid && (finalState.splitHH < CONFIG.limits.maxHH),
                    actual: null,
                    sweep: null
                };
                
                this.setBtnState('start', 'START');
                this.els.flashTray.classList.add('active');
                this.highlightGrid();
            }

            renderGrid() {
                const c = document.getElementById('flash-grid');
                c.innerHTML = '';
                CONFIG.gridMap.forEach(i => {
                    const b = document.createElement('div');
                    if (i.t === 'e') {
                        // empty
                    } else {
                        b.className = `fg-btn fg-${i.t === 'p' ? 'player' : i.t === 'z' ? 'zone' : i.t === 's' ? 'sweep' : 'discard'}`;
                        b.innerText = i.n || this.app.session.profiles[i.id];
                        if(i.t==='p') { b.dataset.action = 'grid-player'; b.dataset.id = i.id; b.id = `gp-${i.id}`; }
                        if(i.t==='z') { b.dataset.action = 'grid-zone'; b.dataset.val = CONFIG.zones.find(z=>z.n===i.n).d; b.id = `gz-${i.n}`; }
                        if(i.t==='s') { b.dataset.action = 'grid-sweep'; b.dataset.val = CONFIG.sweeps.find(s=>s.n===i.n).v; b.id = `gs-${i.n}`; }
                        if(i.t==='d') { b.dataset.action = 'grid-discard'; }
                    }
                    c.appendChild(b);
                });
            }

            highlightGrid() {
                document.querySelectorAll('.fg-btn').forEach(b => b.classList.remove('selected', 'disabled'));
                
                if(!this.tempShot) return;

                if(this.tempShot.player !== 'TEAM') {
                    const el = document.getElementById(`gp-${this.tempShot.player}`);
                    if(el) el.classList.add('selected');
                }

                if(this.tempShot.actual !== null) {
                    const z = CONFIG.zones.find(z => z.d === this.tempShot.actual);
                    if(z) document.getElementById(`gz-${z.n}`).classList.add('selected');
                }
                if(this.tempShot.sweep !== null) {
                    const s = CONFIG.sweeps.find(s => s.v === this.tempShot.sweep);
                    if(s) document.getElementById(`gs-${s.n}`).classList.add('selected');
                }

                if (!this.tempShot.useBH) {
                    document.querySelectorAll('.fg-sweep').forEach(b => b.classList.add('disabled'));
                }
            }

            checkCommit() {
                if(!this.tempShot) return;
                
                const needsSweep = this.tempShot.useBH; 
                const hasZone = this.tempShot.actual !== null;
                const hasSweep = this.tempShot.sweep !== null;

                if (hasZone && (!needsSweep || hasSweep)) {
                    // Update highlight one last time to ensure final sweep selection is visible
                    this.highlightGrid(); 
                    
                    this.app.session.addShot(this.tempShot);
                    this.tempShot = null;
                    this.els.flashTray.classList.remove('active');
                    this.updateRefTable();
                } else {
                    this.highlightGrid();
                }
            }

            setBtnState(state, text) {
                this.els.btnMain.className = '';
                this.els.btnMain.classList.add(`btn-state-${state}`);
                this.els.btnMain.innerText = text;
            }

            updateProfileUI() {
                ['Skip','3rd','2nd','Lead'].forEach(id => {
                    const btn = document.getElementById(`btn-${id}`);
                    btn.innerText = this.app.session.profiles[id];
                    btn.classList.toggle('active', id === this.app.session.activeProfile);
                });
                const pName = this.app.session.activeProfile === 'TEAM' ? 'TEAM' : this.app.session.profiles[this.app.session.activeProfile];
                document.getElementById('ref-header').innerText = `Live Ice Speeds (${pName})`;
            }

            updateRefTable() {
                const tbl = this.els.refTable;
                tbl.innerHTML = '';
                const rows = [11.0, 10.0, 7.0, 4.0, 2.0]; // Hack, B12, Tee, T12, Mid
                
                // Calculate Manual Offset in Distance (Approx)
                let extraOffset = 0;
                if(this.app.session.activeProfile !== 'TEAM') {
                     const sec = this.app.session.manualOffsets[this.app.session.activeProfile] || 0;
                     extraOffset = sec * CONFIG.physics.bhSlope;
                }

                rows.forEach(zoneVal => {
                    const z = CONFIG.zones.find(x => x.v === zoneVal);
                    if(!z) return;
                    
                    const dist = z.d;
                    const bhTime = (dist - CONFIG.physics.bhIntercept - this.app.session.iceOffsetBH - extraOffset) / CONFIG.physics.bhSlope;
                    const hhTime = (dist - CONFIG.physics.hhIntercept - this.app.session.iceOffsetHH) / CONFIG.physics.hhSlope;
                    
                    const color = z.n === 'TEE' ? 'var(--c-green)' : '#fff';
                    tbl.innerHTML += `<tr style="color:${color}"><td>${z.n}</td><td>${bhTime.toFixed(2)}</td><td>${hhTime.toFixed(2)}</td></tr>`;
                });
            }

            /* --- MENU & MODALS --- */

            showMenu() {
                this.els.modal.dataset.view = 'menu';
                this.els.modalContent.innerHTML = `
                    <div class="modal-header">Menu</div>
                    <ul class="modal-list">
                        <li><button onclick="app.ui.showHistory()">View History</button></li>
                        <li><button onclick="app.ui.showGraph('BH')">Graph (Back-Hog)</button></li>
                        <li><button onclick="app.ui.showGraph('HH')">Graph (Hog-Hog)</button></li>
                        <li><button onclick="app.ui.showGraph('BH-Error')">Error Plot (BH)</button></li>
                        <li><button onclick="app.ui.showGraph('HH-Error')">Error Plot (HH)</button></li>
                        <li><button data-action="open-archives" style="color:var(--c-orange); border-color:var(--c-orange)">Saved Games</button></li>
                        <li><button data-action="do-export" style="color:var(--c-blue); border-color:var(--c-blue)">Save & Export</button></li>
                        <li><button onclick="app.resetData()" style="color:var(--c-red); border-color:var(--c-red)">Clear Data</button></li>
                        <li><button data-action="close-modal" style="color:#666; margin-top:10px;">Close</button></li>
                    </ul>
                `;
                this.els.modal.classList.add('open');
            }

            showArchives() {
                this.els.modal.dataset.view = 'sub';
                let list = '';
                if(this.app.session.archives.length === 0) list = '<div style="text-align:center; color:#666; padding:20px;">No saved games</div>';
                else {
                    this.app.session.archives.forEach(a => {
                        list += `
                        <div style="background:#333; padding:10px; margin-bottom:8px; border-radius:8px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-weight:700; color:#fff;">${a.name}</div>
                                <div style="font-size:10px; color:#888;">${a.date}</div>
                            </div>
                            <div style="display:flex; gap:8px;">
                                <button data-action="load-archive" data-id="${a.id}" style="padding:6px 10px; font-size:11px; background:var(--c-blue); color:#fff; border:none; border-radius:4px;">LOAD</button>
                                <button data-action="delete-archive" data-id="${a.id}" style="padding:6px 10px; font-size:11px; background:var(--c-red); color:#fff; border:none; border-radius:4px;">DEL</button>
                            </div>
                        </div>`;
                    });
                }

                this.els.modalContent.innerHTML = `
                    <div class="modal-header">Saved Games</div>
                    <div class="modal-content-scroll">${list}</div>
                    <button data-action="back-menu" style="width:100%; padding:14px; margin-top:10px; background:transparent; border:1px solid #444; color:#666; border-radius:8px;">Back</button>
                `;
            }

            showHistory() {
                this.els.modal.dataset.view = 'sub';
                let rows = '';
                this.app.session.history.forEach(s => {
                    const sw = s.sweep ? (s.sweep === 3 ? 'L' : s.sweep === 6 ? 'M' : s.sweep === 9 ? 'H' : '-') : '-';
                    const res = CONFIG.zones.find(z => z.d === s.actual)?.n || '-';
                    const pName = (s.player === 'TEAM' || !s.player) ? '-' : (this.app.session.profiles[s.player] || s.player).substring(0,4);
                    
                    const bhOut = this.app.session.outliersBH.has(s.id);
                    const hhOut = this.app.session.outliersHH.has(s.id);

                    rows += `<tr>
                        <td>${pName}</td>
                        <td class="${!s.useBH ? 'h-dim' : bhOut ? 'h-outlier' : ''}">${s.bh.toFixed(2)}</td>
                        <td class="${!s.useHH ? 'h-dim' : hhOut ? 'h-outlier' : ''}">${s.hh.toFixed(2)}</td>
                        <td>${res}</td>
                        <td class="h-dim">${sw}</td>
                    </tr>`;
                });

                this.els.modalContent.innerHTML = `
                    <div class="modal-header">History</div>
                    <div class="modal-content-scroll">
                        <table class="hist-table">
                            <thead><tr><th>Ply</th><th>BH</th><th>HH</th><th>Res</th><th>Sw</th></tr></thead>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                    <button data-action="back-menu" style="width:100%; padding:14px; margin-top:10px; background:transparent; border:1px solid #444; color:#666; border-radius:8px;">Back</button>
                `;
            }

            showProfileModal(id) {
                this.els.modal.dataset.view = 'modal';
                const currentName = this.app.session.profiles[id];
                this.tempOffset = this.app.session.manualOffsets[id] || 0;
                
                // Calculations for Stats
                const teamTee = (21.0 - CONFIG.physics.bhIntercept - this.app.session.iceOffsetBH) / CONFIG.physics.bhSlope;
                const pErr = this.app.session.getPlayerMeanError(id);
                const pTee = (21.0 - CONFIG.physics.bhIntercept - pErr) / CONFIG.physics.bhSlope;
                const diff = pTee - teamTee;
                const sign = diff > 0 ? "+" : "";
                
                this.els.modalContent.innerHTML = `
                    <div class="modal-header">Profile: ${currentName}</div>
                    <input id="rename-input" class="input-rename" value="${currentName}" maxlength="5" />
                    
                    <div class="stat-row"><span>Team Tee:</span><span>${teamTee.toFixed(2)}s</span></div>
                    <div class="stat-row"><span>Player Tee:</span><span>${pTee.toFixed(2)}s</span></div>
                    <div class="stat-row" style="margin-bottom:20px;"><span>Difference:</span><span style="color:${diff===0?'#fff':diff>0?'var(--c-red)':'var(--c-green)'}">${sign}${diff.toFixed(2)}s</span></div>
                    
                    <div style="text-align:center; font-size:12px; color:#888; text-transform:uppercase;">Manual Offset (Applied)</div>
                    <div class="stepper-row">
                        <button class="step-btn" data-action="adj-offset" data-val="-0.01">-0.01</button>
                        <div class="offset-val" id="offset-val">${(this.tempOffset>0?"+":"")+this.tempOffset.toFixed(2)}</div>
                        <button class="step-btn" data-action="adj-offset" data-val="0.01">+0.01</button>
                    </div>

                    <button class="p-btn" data-action="save-profile" data-id="${id}" style="height:50px; background:var(--c-green); color:#000; font-size:16px;">SAVE</button>
                    <button data-action="close-modal" style="width:100%; padding:14px; margin-top:10px; background:transparent; border:1px solid #444; color:#666; border-radius:8px;">Cancel</button>
                `;
                this.els.modal.classList.add('open');
            }

            showGraph(type) {
                this.els.modal.dataset.view = 'sub';
                const titles = {
                    'BH': 'Back-to-Hog', 'HH': 'Hog-to-Hog',
                    'BH-Error': 'BH Error (Feet)', 'HH-Error': 'HH Error (Feet)'
                };
                
                this.els.modalContent.innerHTML = `
                    <div class="modal-header">${titles[type]}</div>
                    <canvas id="graph-canvas"></canvas>
                    <div class="graph-legend">
                        ${Object.keys(CONFIG.colors).map(k => k!=='-' ? `<div class="legend-item"><span class="dot" style="background:${CONFIG.colors[k]}"></span>${this.app.session.profiles[k] || k}</div>` : '').join('')}
                    </div>
                    <button data-action="back-menu" style="width:100%; padding:14px; margin-top:10px; background:transparent; border:1px solid #444; color:#666; border-radius:8px;">Back</button>
                `;
                
                // Draw Graph
                setTimeout(() => {
                    const canvas = document.getElementById('graph-canvas');
                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width * 2; canvas.height = rect.height * 2;
                    ctx.scale(2, 2);
                    
                    if (type.includes('Error')) this.drawErrorGraph(ctx, type, rect.width, rect.height);
                    else this.drawGraph(ctx, type, rect.width, rect.height);
                }, 50);
            }

            drawGraph(ctx, type, w, h) {
                const xMin = type === 'BH' ? 3.5 : 13.0; const xMax = type === 'BH' ? 4.6 : 17.5;
                const yMin = 5; const yMax = 30;
                
                const mapX = (v) => ((v - xMin) / (xMax - xMin)) * w;
                const mapY = (v) => h - ((v - yMin) / (yMax - yMin)) * h;

                // Axis with Specific Labels
                const labels = ['Mid', 'Tight', 'T 12', 'T 8', 'TEE', 'B 8', 'B 12'];
                ctx.font = "10px sans-serif";
                ctx.textAlign = "left";
                
                labels.forEach(name => {
                    const z = CONFIG.zones.find(z => z.n === name || z.n === name.replace(' ', ''));
                    if(z) {
                        let y = mapY(z.d);
                        ctx.strokeStyle = '#333'; 
                        ctx.beginPath(); 
                        ctx.moveTo(0, y); ctx.lineTo(w, y); 
                        ctx.stroke();
                        ctx.fillStyle = '#666';
                        ctx.fillText(name, 2, y - 2); 
                    }
                });

                // Calibration Line
                const slope = type === 'BH' ? CONFIG.physics.bhSlope : CONFIG.physics.hhSlope;
                const int = type === 'BH' ? CONFIG.physics.bhIntercept : CONFIG.physics.hhIntercept;
                const off = type === 'BH' ? this.app.session.iceOffsetBH : this.app.session.iceOffsetHH;
                
                ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, mapY((slope * xMin) + int + off));
                ctx.lineTo(w, mapY((slope * xMax) + int + off));
                ctx.stroke();

                // Points
                this.app.session.history.forEach(s => {
                    if(!s.actual) return;
                    let t = type === 'BH' ? s.bh : s.hh;
                    if(t < xMin || t > xMax) return;
                    
                    let y = s.actual;
                    if(type === 'BH' && s.sweep) y -= s.sweep;

                    ctx.fillStyle = CONFIG.colors[s.player] || '#666';
                    if(s.player !== '-' && !CONFIG.colors[s.player]) {
                         ctx.fillStyle = CONFIG.colors[Object.keys(CONFIG.colors).find(k => k === s.player)] || '#666';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(mapX(t), mapY(y), 4, 0, Math.PI*2);
                    ctx.fill();
                });
            }

            drawErrorGraph(ctx, type, w, h) {
                const yRange = 10;
                const shots = this.app.session.history.filter(s => s.actual !== null && (type === 'BH-Error' ? s.useBH : s.useHH));
                
                if(shots.length === 0) return;

                const mapX = (idx) => (idx / (shots.length + 1)) * w; 
                const mapY = (val) => (h/2) - ((val / yRange) * (h/2)); 

                // Zero Line
                ctx.strokeStyle = '#444'; ctx.lineWidth = 1; ctx.beginPath();
                ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                
                // Grid Lines
                ctx.strokeStyle = '#222'; ctx.beginPath();
                ctx.moveTo(0, mapY(5)); ctx.lineTo(w, mapY(5));
                ctx.moveTo(0, mapY(-5)); ctx.lineTo(w, mapY(-5));
                ctx.stroke();

                ctx.fillStyle = '#666'; ctx.font = "10px sans-serif";
                ctx.fillText("+5ft", 5, mapY(5)-2);
                ctx.fillText("0", 5, h/2-2);
                ctx.fillText("-5ft", 5, mapY(-5)-2);

                const slope = type === 'BH-Error' ? CONFIG.physics.bhSlope : CONFIG.physics.hhSlope;
                const int = type === 'BH-Error' ? CONFIG.physics.bhIntercept : CONFIG.physics.hhIntercept;
                
                for(let i=0; i<shots.length; i++) {
                    const s = shots[i];
                    const xIdx = shots.length - i; 
                    
                    const off = (type === 'BH-Error') 
                        ? (s.offsetBH !== undefined ? s.offsetBH : this.app.session.iceOffsetBH)
                        : (s.offsetHH !== undefined ? s.offsetHH : this.app.session.iceOffsetHH);

                    const time = type === 'BH-Error' ? s.bh : s.hh;
                    const pred = (slope * time) + int + off;
                    let act = s.actual;
                    if(type === 'BH-Error' && s.sweep) act -= s.sweep;
                    const err = act - pred; 
                    
                    const cx = mapX(xIdx);
                    const cy = mapY(err);

                    ctx.fillStyle = CONFIG.colors[s.player] || '#666';
                    if(s.player !== '-' && !CONFIG.colors[s.player]) {
                         ctx.fillStyle = CONFIG.colors[Object.keys(CONFIG.colors).find(k => k === s.player)] || '#666';
                    }

                    ctx.beginPath();
                    ctx.arc(cx, cy, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        /**
         * =========================================
         * 5. APP INIT (Glue)
         * =========================================
         */
        class App {
            constructor() {
                this.session = new Session();
                this.timer = new Stopwatch();
                this.ui = new UI(this);
                
                // Connect Timer Logic to UI
                this.timer.onTick = (t) => this.ui.update(t);
                this.timer.onFinish = (t) => this.ui.activateInput(t);
                
                // Init UI
                this.ui.updateProfileUI();
                this.ui.updateRefTable();
                // RESET TO CLEAN STATE ON LOAD
                this.ui.update(this.timer);
            }

            reset() {
                this.timer.reset();
                this.ui.els.flashTray.classList.remove('active');
                this.ui.update(this.timer);
            }
            
            resetData() {
                if(confirm("Delete all history?")) {
                    this.session.history = [];
                    this.session.iceOffsetBH = 0;
                    this.session.iceOffsetHH = 0;
                    this.session.manualOffsets = { 'Skip':0, '3rd':0, '2nd':0, 'Lead':0 };
                    this.session.save();
                    this.ui.updateRefTable();
                    this.ui.handleAction('close-modal');
                }
            }
        }

        // Start
        const app = new App();

    </script>
</body>
</html>